# 交叉编译入门指南

> 本文档面向首次接触交叉编译的开发者，结合当前 CMake 学习工程，介绍交叉编译的基本概念、工具链配置步骤以及完整示例。

## 1. 基础概念速览

| 名词 | 说明 |
| ---- | ---- |
| **Build 平台** | 执行编译命令的机器（通常是本地 PC）。 |
| **Host 平台** | 生成的可执行文件最终运行的系统。交叉编译时，Host ≠ Build。 |
| **Target 平台** | 对于编译器自身的构建目标。常见场景下 `Host == Target`，对于交叉编译工具链可忽略差异。 |
| **交叉工具链** | 专门面向另一套架构/系统的编译器、链接器、标准库等集合，例如 `arm-linux-gnueabihf-g++`。 |
| **Sysroot** | 目标平台的头文件、库和运行时环境快照。编译时通过 `--sysroot` 或 CMake 变量指向它。 |

> 记忆技巧：**B**uild 机器造代码，**H**ost 机器跑程序。

## 2. 交叉工具链核心组成

1. **交叉编译器**：如 GCC/Clang 的交叉版本（`aarch64-linux-gnu-g++`）。
2. **Binutils**：`ld`、`ar`、`objcopy` 等，通常与编译器同前缀安装。
3. **目标运行时/标准库**：glibc、libstdc++ 等，对应目标架构。
4. **CMake Toolchain 文件**：告知 CMake 使用哪套编译器、sysroot、查找规则。
5. **附加工具**：`pkg-config`、`qemu`、`ssh` 等，用于依赖检测或部署调试。

## 3. 编写 CMake 工具链文件

新建 `cmake/toolchains/arm-linux-gnueabihf.cmake`（示例见下文），核心指令说明：

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(TRIPLE arm-linux-gnueabihf)
set(CMAKE_C_COMPILER   ${TRIPLE}-gcc)
set(CMAKE_CXX_COMPILER ${TRIPLE}-g++)

# 如果交叉工具链提供 sysroot，传入绝对路径
# set(CMAKE_SYSROOT "/opt/arm-sysroot")

# 控制 find_* 搜索路径，优先使用目标平台文件
set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT} /usr/${TRIPLE})
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
```

- `CMAKE_SYSTEM_NAME` 告诉 CMake 目标平台；
- `CMAKE_CXX_COMPILER` 等指定具体编译器；
- `CMAKE_FIND_ROOT_PATH_*` 让 CMake 在目标 sysroot 内寻找头文件和库，避免误用本机依赖；
- 如果交叉链中缺省 `pkg-config`，可通过 `PKG_CONFIG_PATH`/`PKG_CONFIG_SYSROOT_DIR` 控制。

> 工具链文件是交叉编译的入口点 —— 没有它 CMake 会把我们当成本地编译。

## 4. 在当前工程中实践

### 4.1 准备环境

1. 安装交叉工具链（以 Debian/Ubuntu 为例）：

   ```bash
   sudo apt install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
   ```

2. 如需 sysroot，可从目标设备上同步 `/usr`, `/lib`, `/lib64` 等目录，放到 `/opt/sysroots/armhf`。
3. 将示例工具链文件复制到工程根目录：

   ```bash
   mkdir -p cmake/toolchains
   cp docs/示例文件内容...（详见下一节）
   ```

### 4.2 配置与构建命令

```bash
# 进入工程根目录
cd /path/to/cmake_learning_project

# 清理旧构建并为 ARMv7 架构生成新构建
rm -rf build-armhf
cmake -S . -B build-armhf \
      -DCMAKE_BUILD_TYPE=Release \
      -DCMAKE_TOOLCHAIN_FILE=cmake/toolchains/arm-linux-gnueabihf.cmake \
      -DCMAKE_SYSROOT=/opt/sysroots/armhf \
      -DFETCHCONTENT_FULLY_DISCONNECTED=ON
cmake --build build-armhf --parallel
```

- `-DCMAKE_TOOLCHAIN_FILE`：指定刚才创建的工具链文件；
- `-DCMAKE_SYSROOT`：向工具链文件传递 sysroot 路径（若工具链本身已封装，可省略）；
- `-DFETCHCONTENT_FULLY_DISCONNECTED=ON`：防止交叉环境下拉取依赖失败，使用 `3rd/` 本地包。

### 4.3 生成产物

`build-armhf/bin/` 下即可得到适用于 ARM Linux 的可执行文件；
`build-armhf/lib/` 存放静态库或动态库。可通过 `file build-armhf/bin/simple_demo` 验证架构。

## 5. 示例：arm-linux-gnueabihf 工具链文件

> 位置：`cmake/toolchains/arm-linux-gnueabihf.cmake`

```cmake
# 目标平台基本信息
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

# 交叉编译器前缀
set(TRIPLE arm-linux-gnueabihf)

# 指定编译器
set(CMAKE_C_COMPILER   ${TRIPLE}-gcc)
set(CMAKE_CXX_COMPILER ${TRIPLE}-g++)

# 如果工具链包已经内置 sysroot，可省略；否则外部传参
if(DEFINED CMAKE_SYSROOT)
    set(CMAKE_SYSROOT "${CMAKE_SYSROOT}")
endif()

# 避免使用宿主系统的库和头
set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT} /usr/${TRIPLE})
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

# 可选：指定默认架构特性
add_compile_options(-march=armv7-a -mfpu=vfpv3 -mfloat-abi=hard)
```

## 6. 常见问题与排查

| 问题 | 可能原因 | 解决建议 |
| ---- | -------- | -------- |
| 找不到头文件/库 | `CMAKE_SYSROOT` 未设置或路径错误 | 确认 sysroot 路径是否包含 `usr/include`、`usr/lib`。 |
| 链接阶段引用宿主库 | `CMAKE_FIND_ROOT_PATH_MODE_*` 未限制 | 调整工具链文件，确保为 `ONLY`。 |
| 依赖包配置失败 | `pkg-config` 当前寻找宿主配置 | 设定 `PKG_CONFIG_LIBDIR`、`PKG_CONFIG_SYSROOT_DIR` 指向目标 sysroot。 |
| 可执行文件仍是 x86 | 工具链文件未被使用 | 检查 `cmake ..` 命令是否传入 `-DCMAKE_TOOLCHAIN_FILE`，或通过 `CMakeCache.txt` 中的 `CMAKE_CXX_COMPILER` 验证。 |

## 7. 进一步学习资料

- [CMake 官方 Cross Compiling 指南](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html)
- [Yocto Project Sysroot 介绍](https://docs.yoctoproject.org/)——理解 sysroot 的组织形式
- [交叉调试工具链（gdbserver + gdb）](https://sourceware.org/gdb/onlinedocs/)

---

**实战建议**：

1. 先在本地虚拟机或 Docker 中模拟目标平台，确认可执行文件能运行；
2. 使用 `ctest` 时需确保目标平台也能获得同套测试数据，可考虑通过 QEMU 或远程执行；
3. 将 `cmake/toolchains/*.cmake` 纳入版本管理，方便团队共享交叉编译配置。
